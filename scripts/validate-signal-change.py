#!/usr/bin/env python3
"""
Signal Change Review (SCR) Validation Script
=============================================
Automates the SCR checklist for signal logic changes. Runs A/B backtests,
analyzes volatile period performance, and generates a pre-filled SCR
document for human review.

Usage:
    python scripts/validate-signal-change.py \
        --config-name v4c_combined \
        --baseline current \
        --days 365 \
        --output docs/signal-reviews/SCR-001-v4-combined.md

    python scripts/validate-signal-change.py --config-name v4a_confirmation
    # Uses defaults: baseline=current, days=365, output=auto-generated

Requires backtest.py dependencies:
    pip install -r scripts/requirements-backtest.txt
"""

import argparse
import sys
import time
from datetime import datetime, timezone
from pathlib import Path

# Import backtest infrastructure
sys.path.insert(0, str(Path(__file__).resolve().parent))
from backtest import (
    NAMED_CONFIGS,
    POSITION_SIZE_USD,
    CG_SLEEP_SECONDS,
    fetch_assets,
    fetch_historical_ohlc,
    calculate_indicators,
    run_backtest,
    extract_metrics,
    print_comparison,
    identify_volatile_periods,
    measure_period_performance,
    compute_buy_and_hold,
    print_volatile_period_report,
)


def generate_scr_report(
    config_name: str,
    baseline_name: str,
    config: dict,
    baseline: dict,
    days: int,
    per_asset_results: dict,
    aggregate: dict,
    volatile_results: dict,
    bnh_results: dict,
) -> str:
    """Generate a markdown SCR report from backtest results."""

    today = datetime.now(timezone.utc).strftime("%Y-%m-%d")
    config_display = config.get("name", config_name)
    baseline_display = baseline.get("name", baseline_name)

    # Build config diff table
    diff_rows = []
    all_keys = set(list(config.keys()) + list(baseline.keys())) - {"name"}
    for key in sorted(all_keys):
        va = baseline.get(key, "n/a")
        vb = config.get(key, "n/a")
        if va != vb:
            diff_rows.append(f"| `{key}` | `{va}` | `{vb}` |")

    diff_table = "\n".join(diff_rows) if diff_rows else "| (no differences) | | |"

    # Build per-asset summary
    asset_rows = []
    for asset_name, data in per_asset_results.items():
        m_a = data["baseline_metrics"]
        m_b = data["proposed_metrics"]
        delta = m_b["total_pnl_usd"] - m_a["total_pnl_usd"]
        wr_delta = m_b["win_rate"] - m_a["win_rate"]
        asset_rows.append(
            f"| {asset_name} | ${m_a['total_pnl_usd']:+,.0f} | ${m_b['total_pnl_usd']:+,.0f} | "
            f"${delta:+,.0f} | {m_a['win_rate']:.0f}% â†’ {m_b['win_rate']:.0f}% ({wr_delta:+.0f}pp) |"
        )
    asset_table = "\n".join(asset_rows)

    # Volatile period summary
    volatile_rows = []
    for asset_name, vdata in volatile_results.items():
        for p in vdata["periods"]:
            b_perf = measure_period_performance(vdata["baseline_trades"], p["start_date"], p["end_date"])
            p_perf = measure_period_performance(vdata["proposed_trades"], p["start_date"], p["end_date"])
            delta = p_perf["total_pnl_usd"] - b_perf["total_pnl_usd"]
            volatile_rows.append(
                f"| {asset_name} | {p['start_date']} â†’ {p['end_date']} | {p['drawdown_pct']:+.1f}% | "
                f"${b_perf['total_pnl_usd']:+,.0f} | ${p_perf['total_pnl_usd']:+,.0f} | ${delta:+,.0f} |"
            )
    volatile_table = "\n".join(volatile_rows) if volatile_rows else "| (no volatile periods) | | | | | |"

    # Buy-and-hold comparison
    bnh_rows = []
    for asset_name, bdata in bnh_results.items():
        bnh_rows.append(
            f"| {asset_name} | {bdata['bnh_pct']:+.1f}% | {bdata['baseline_pct']:+.1f}% | {bdata['proposed_pct']:+.1f}% |"
        )
    bnh_table = "\n".join(bnh_rows)

    # Regression check
    regressions = []
    for asset_name, data in per_asset_results.items():
        m_a = data["baseline_metrics"]
        m_b = data["proposed_metrics"]
        if m_a["total_pnl_usd"] != 0:
            pnl_change_pct = ((m_b["total_pnl_usd"] - m_a["total_pnl_usd"]) / abs(m_a["total_pnl_usd"])) * 100
            if pnl_change_pct < -10:
                regressions.append(f"- **{asset_name}**: P&L regressed by {pnl_change_pct:.0f}%")

    regression_status = "PASS" if not regressions else "FAIL"
    regression_detail = "\n".join(regressions) if regressions else "No regressions detected."

    agg_a = aggregate["baseline"]
    agg_b = aggregate["proposed"]
    total_delta = (agg_b["total_pnl_usd"] + agg_b.get("open_pnl_usd", 0)) - (agg_a["total_pnl_usd"] + agg_a.get("open_pnl_usd", 0))

    report = f"""# SCR-AUTO: {config_display}

> **Author:** Auto-generated by validate-signal-change.py
> **Date:** {today}
> **Status:** Under Review
> **Backtest Config:** `{config_name}` vs `{baseline_name}`
> **Lookback:** {days} days | **Position Size:** ${POSITION_SIZE_USD:,}

---

## Config Changes

| Parameter | {baseline_display} | {config_display} |
|---|---|---|
{diff_table}

---

## Backtest Results

### Per-Asset Comparison

| Asset | Baseline P&L | Proposed P&L | Delta | Win Rate |
|---|---|---|---|---|
{asset_table}

### Aggregate

| Metric | Baseline | Proposed | Delta |
|---|---|---|---|
| Total P&L (closed) | ${agg_a['total_pnl_usd']:+,.0f} | ${agg_b['total_pnl_usd']:+,.0f} | ${agg_b['total_pnl_usd'] - agg_a['total_pnl_usd']:+,.0f} |
| Win Rate | {agg_a['win_rate']:.0f}% | {agg_b['win_rate']:.0f}% | {agg_b['win_rate'] - agg_a['win_rate']:+.0f}pp |
| Max Single Loss | {agg_a['max_single_loss_pct']:+.1f}% | {agg_b['max_single_loss_pct']:+.1f}% | {agg_b['max_single_loss_pct'] - agg_a['max_single_loss_pct']:+.1f}pp |
| Total P&L (incl. open) | ${agg_a['total_pnl_usd'] + agg_a.get('open_pnl_usd', 0):+,.0f} | ${agg_b['total_pnl_usd'] + agg_b.get('open_pnl_usd', 0):+,.0f} | ${total_delta:+,.0f} |

### Regression Gate: **{regression_status}**

{regression_detail}

---

## Volatile Period Analysis

| Asset | Period | Drawdown | Baseline P&L | Proposed P&L | Delta |
|---|---|---|---|---|---|
{volatile_table}

---

## Buy-and-Hold Comparison

| Asset | Buy & Hold | Baseline Model | Proposed Model |
|---|---|---|---|
{bnh_table}

---

## Logical Consistency Check

> **TODO:** Fill in manually before approval.

### Rule 1: [Name]

| Check | Answer |
|---|---|
| At extreme values, does this still make sense? | |
| What happens to EXISTING open positions? | |
| What happens to NEW position entries? | |
| Conflicts with existing rules? | |
| Inversion test | |
| Harmful regime? | |

---

## Adversarial Review

> **TODO:** Fill in manually before approval.

| Threat | Severity | Assessment |
|---|---|---|
| Can this change be exploited? | | |
| Worst-case loss scenario? | | |
| Interaction with circuit breakers? | | |

---

## Rollback Plan

> **TODO:** Fill in manually before approval.

---

## Approval Checklist

- [{"x" if regression_status == "PASS" else " "}] Backtest shows no >10% regression in any asset
- [ ] No logical contradictions identified in consistency check
- [ ] Inversion test passed for all rules
- [ ] Volatile period analysis shows improvement during crashes
- [ ] Worst-case loss scenario bounded
- [ ] Rollback path confirmed
"""
    return report


def main():
    parser = argparse.ArgumentParser(description="Signal Change Review Validation")
    parser.add_argument("--config-name", required=True,
                        help=f"Proposed config name ({', '.join(NAMED_CONFIGS.keys())})")
    parser.add_argument("--baseline", default="current",
                        help=f"Baseline config name (default: current)")
    parser.add_argument("--days", type=int, default=365, help="Lookback days (default: 365)")
    parser.add_argument("--output", type=str, default=None,
                        help="Output markdown file path (default: auto-generated)")
    args = parser.parse_args()

    config = NAMED_CONFIGS.get(args.config_name)
    if config is None:
        print(f"  Unknown config: '{args.config_name}'. Options: {', '.join(NAMED_CONFIGS.keys())}")
        sys.exit(1)

    baseline = NAMED_CONFIGS.get(args.baseline)
    if baseline is None:
        print(f"  Unknown baseline: '{args.baseline}'. Options: {', '.join(NAMED_CONFIGS.keys())}")
        sys.exit(1)

    output_path = args.output or f"docs/signal-reviews/SCR-{args.config_name}-{datetime.now().strftime('%Y%m%d')}.md"

    print(f"\n{'=' * 74}")
    print(f"  SIGNAL CHANGE REVIEW VALIDATION")
    print(f"  Proposed: {config.get('name', args.config_name)}")
    print(f"  Baseline: {baseline.get('name', args.baseline)}")
    print(f"  Lookback: {args.days} days")
    print(f"{'=' * 74}")

    # Fetch assets
    assets = fetch_assets()
    if not assets:
        print("  No assets found.")
        sys.exit(1)

    # Pre-fetch BTC data for crash filter
    btc_df = None
    if config.get("btc_crash_filter", False):
        print(f"\n  Pre-fetching BTC data for crash filter...")
        btc_raw = fetch_historical_ohlc("bitcoin", args.days)
        btc_df = calculate_indicators(btc_raw, config=baseline)
        time.sleep(CG_SLEEP_SECONDS)

    # Run backtests per asset
    per_asset_results = {}
    volatile_results = {}
    bnh_results = {}
    all_metrics_a = []
    all_metrics_b = []

    for i, asset in enumerate(assets):
        cg_id = asset["coingecko_id"]
        symbol = asset["symbol"]
        a_id = asset["id"]

        print(f"\n  [{i+1}/{len(assets)}] {symbol} ({cg_id})...")

        df_raw = fetch_historical_ohlc(cg_id, args.days)
        df_indicators = calculate_indicators(df_raw.copy(), config=config)
        is_btc = cg_id == "bitcoin"

        trades_a = run_backtest(cg_id, a_id, args.days, dry_run=True, config=baseline,
                                df_cached=df_raw, quiet=True, btc_df=None)
        trades_b = run_backtest(cg_id, a_id, args.days, dry_run=True, config=config,
                                df_cached=df_raw, quiet=True, btc_df=btc_df if not is_btc else None)

        metrics_a = extract_metrics(trades_a)
        metrics_b = extract_metrics(trades_b)
        all_metrics_a.append(metrics_a)
        all_metrics_b.append(metrics_b)

        per_asset_results[symbol] = {
            "baseline_metrics": metrics_a,
            "proposed_metrics": metrics_b,
        }

        # Volatile periods
        periods = identify_volatile_periods(df_indicators, n=5, window_days=7)
        volatile_results[symbol] = {
            "periods": periods,
            "baseline_trades": trades_a,
            "proposed_trades": trades_b,
        }

        # Buy and hold
        bnh_pct = compute_buy_and_hold(df_indicators)
        a_pct = metrics_a["total_pnl_usd"] / POSITION_SIZE_USD * 100 if POSITION_SIZE_USD else 0
        b_pct = metrics_b["total_pnl_usd"] / POSITION_SIZE_USD * 100 if POSITION_SIZE_USD else 0
        bnh_results[symbol] = {"bnh_pct": bnh_pct, "baseline_pct": a_pct, "proposed_pct": b_pct}

        # Print comparison
        print_comparison(f"{symbol} ({cg_id})", metrics_a, metrics_b, baseline, config)
        print_volatile_period_report(periods, trades_a, trades_b, symbol,
                                      baseline_name=baseline.get("name", args.baseline),
                                      proposed_name=config.get("name", args.config_name))

        if i < len(assets) - 1:
            time.sleep(CG_SLEEP_SECONDS)

    # Aggregate
    from backtest import _aggregate_metrics
    agg_a = _aggregate_metrics(all_metrics_a)
    agg_b = _aggregate_metrics(all_metrics_b)

    aggregate = {"baseline": agg_a, "proposed": agg_b}

    # Generate report
    report = generate_scr_report(
        config_name=args.config_name,
        baseline_name=args.baseline,
        config=config,
        baseline=baseline,
        days=args.days,
        per_asset_results=per_asset_results,
        aggregate=aggregate,
        volatile_results=volatile_results,
        bnh_results=bnh_results,
    )

    # Write report
    output = Path(output_path)
    output.parent.mkdir(parents=True, exist_ok=True)
    output.write_text(report)
    print(f"\n  ðŸ“ SCR report written to: {output_path}")

    # Check regression gate
    has_regression = False
    for asset_name, data in per_asset_results.items():
        m_a = data["baseline_metrics"]
        m_b = data["proposed_metrics"]
        if m_a["total_pnl_usd"] != 0:
            pnl_change_pct = ((m_b["total_pnl_usd"] - m_a["total_pnl_usd"]) / abs(m_a["total_pnl_usd"])) * 100
            if pnl_change_pct < -10:
                has_regression = True
                print(f"  âš ï¸  REGRESSION: {asset_name} P&L dropped {pnl_change_pct:.0f}%")

    if has_regression:
        print(f"\n  âŒ REGRESSION GATE FAILED â€” review required before proceeding")
        sys.exit(1)
    else:
        print(f"\n  âœ… REGRESSION GATE PASSED â€” no asset regressed >10%")


if __name__ == "__main__":
    main()
